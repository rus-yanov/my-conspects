СОДЕРЖАНИЕ ПО СТРОКАМ
Бинарный поиск              -26
Big O                       -60
Сортировка выбором          -70
Пузырьковая сортировка      -95
Рекурсия                    -120
Разделяй и властвуй         -155
Быстрая сортировка          -186
Хэш-таблицы                 -240
Поиск в ширину              -320
Алгоритм дейкстры           -390
Жадные алгоритмы            -496
Динамическое програм-е      -545












БИНАРНЫЙ ПОИСК 
алгоритм поиска в отсортированном списке элементов

- при каждой итерации исключается половина элементов
- для списка из n элементов бинарный поиск выполняется за log2n шагов

Код:
// цель: найти индекс item в списке list

int search(List<Integer> list, int item) {
// определяем границы поиска
  int low = 0;
  int high = list.size() - 1;
  
  int mid;
  int guess;
  
  // пока эта часть не сократится до одного элемента
  while (low <= high) {
    mid = (low + high) / 2;
    guess = list.get(mid);
    if (guess == item) {
      return mid ; 
    } else if (guess > item) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return -1;
}
-------------------------------------------------------------------------------

BIG O
сравнивает количество операций, а не скорость в секундах

0(1) - константное время. Пример: обращение к элементу массива по индексу
O(log n) - логарифмическое время. Пример: бинарный поиск
O(n) - линейное время. Пример: простой поиск методом перебора
O(n * log n) - Пример: эффективные алгоритмы сортировки
O(n^2) - Пример: вложеные циклы
O(n!) - факториальное время. Пример: очень медленные алгоритмы
-------------------------------------------------------------------------------

CОРТИРОВКА ВЫБОРОМ
- выполняется за O(n^2) путем перебора массива и перекладывания элементов в новый массив

Код:
// цель:выполнить сортировку массива по возрастванию
// шаг 1 - пишем простой метод для перемены мест чисел в массиве
void swap(int[] array, int ind1, int ind2) {
    int tmp = array[ind1];
    array[ind1] = array[ind2];
    array[ind2] = tmp;
}
// шаг 2 - пишем метод сортировки
int[] selectionSort(int[] array) {
    for (int left = 0; left < array.length; left++) {
        int minInd = left;
        for (int i = left; i < array.length; i++) {
            if (array[i] < array[minInd]) {
                minInd = i;
            }
        }
        swap(array, left, minInd);
    }
    return array;
}
------------------------------------------------------------------------------------

ПУЗЫРЬКОВАЯ СОРТИРОВКА (глупая сортировка)
- выполняется за O(n^2) путем перебора массива и сменой мест с соседним элементом

Код:
// цель:выполнить сортировку массива по возрастванию
// шаг 1 - метод swap (выше)
// шаг 2 - метод сортировки
int[] bubbleSort(int[] array) {
  boolean needIteration = true;
  while (needIteration) {
    needIteration = false;
    for (int i = 1; i < array.length; i++) {
      if (array[i] < array[i - 1]) {
        swap(array, i, i-1);
        needIteration = true;
      }
    }
  }
  return array;
}

Массивы - отлично подходят для чтения элементов в произвольных позициях
Связанные списки - идеально подходят для добавления и удаления, но поддерживают только 
последовательный доступ
---------------------------------------------------------------------------------------

РЕКУРСИЯ
Базовый случай - момент в который необходимо прервать рекурсию
Рекурсивный случай - момент а который необходимо продолжить рекурсию

Код:
// цель: обратный отсчет от i до 1
void countdown(int i) {
  System.out.println(i);
  // базовый случай
  if (i <= 1) {
    return;
  // рекурсивный случай
  } else {
    countdown(i - 1);
  }
}

Стек вызовов
Когда функция(2) вызывается из другой функции(1), вызывающая функция(1) приостанавливается в частично завершенном состоянии. А когда функция 2 будет выполнена, мы вернемся к функции 1, ее выполнение продожится там, где прервалось.

Код:
// нахождение факториала числа x
int fact(int x) {
  if (x == 1) {
    return 1;
  } else {
    return x * fact(x - 1);
  }
}

Минусы:
- сохранение всей промежуточной информации может привести к значительным потерям памяти
-------------------------------------------------------------------------------------------------

РАЗДЕЛЯЙ И ВЛАСТВУЙ
- целый подход к решению задач

шаг 1 - определяем простейший случай как базовый
шаг 2 - придумываем как свести задачу к базовому случаю

Код:
// цель: просуммировать числа в массиве
// способ 1 (без рекурсии)
int findSum(int[] arr) {
  int total = 0;
  for (int num : arr) {
    total += num;
  }
  return total;
}

// способ 2 (с рекурсией)
за базовый случай берем пустой массив либо список и вытаскиваем оттуда по одному элементу пока не наступит базовый случай
// размер массива передаем в параметры
static int findSum(int[] arr, int length) {
  if (length <= 0)
    return 0;
  return (arr[length - 1] + findSum(arr, length - 1));
}

Функциональное программирование
- не предусматривает применение циклов, поэтому все типовые задачи решаются через рекурсию
-------------------------------------------------------------------------------------------------

БЫСТРАЯ СОРТИРОВКА
- работает немного быстрее сортировки выбором

Базовый случай: arr.length == 0 || == 1
-такие массивы просто возвращаются в исходном виде
-массив должен разделяться пока мы не придем к базовому случаю

1-находим ОПОРНЫЙ ЭЛЕМЕНТ
2-делаем разделение - находим элементы больше опорного и меньше 
3-эти элементы образуют 2 подмассива

Код:
// шаг 1 - метод swap

// шаг 2 - разделение
int partition(int arr[], int first, int last)
{
    // Choosing the pivot
    int pivot = arr[last];

    // Setting the wall
    int wall = (first - 1);

    for (int current = first; current < last; current++) {

        // If current element is smaller than the pivot
        if (arr[current] < pivot) {

            // Increment index of wall and do a swap
            wall++;
            swap(arr, wall, current);
        }
    }
    
    swap(arr, wall + 1, last);
    return (wall + 1);
}

// шаг 3 - сортировка
void quickSort(int arr[], int first, int last)
{
    if (first < last) {

        // doing partition
        int pivot = partition(arr, first, last);

        // Separately sort elements before partition and after partition
        quickSort(arr, first, pivot - 1);
        quickSort(arr, pivot + 1, last);
    }
}

--------------------------------------------------------------------------------------------

ХЕШ-ТАБЛИЦЫ

Хеш-функция представляет собой функцию, которая получает строку и возвращает индекс ячейки (бакет) динамически расширяемого массива, иными словами она отображает строки на числа.
Принципы работы:
-при передаче в хеш-функцию одного и того же слова будет возвращен один и тот же индекс
-разным словам соответствуют разные индексы
-хеш-функция неизменно связывает название с одним индексом

хеш-функция + массив = хеш-таблица
!!!Хеш-функция определяет место хранения элемента в массиве и делает это за константное время О(1) в лучшем и среднем случаях и за линейное О(n) в худшем случае

ключ хеш-таблицы - индекс элемента массива
значение хеш-таблицы - сам элемент

КОЛЛИЗИИ

-ситуация при которой двум ключам назначается один элемент массива
Решения коллизий:
-если несколько ключей отображаются на один элемент, тогда в элементе создается связанный список

Таким образом хеш-функция должна распределять ключи равномерно по всему хешу, тк если связанные списки становятся слишком длинными, работа с таблицей сильно замедлится.

КОЭФФИЦИЕНТ ЗАПОЛНЕНИЯ

КЗ = Q элементов в хэш-таблице(занятых ячеек) / общее Q элементов(занятых + пустых ячеек)
-по КЗ можно оценить количество пустых ячеек в хэш-таблице
-чем меньше КЗ - тем лучше
-при КЗ > 0.7 пора изменять размер таблицы

ПРИМЕНЕНИЕ ХЕШ-ТАБЛИЦ:

Преобразование DNS
-это преобразование названия веб-сайта в IP-адрес (например google.com -> 74.125.239.133) 
-работает по принципу хеш-таблицы (название сайта - ключ, IP - значение)

Исключение дубликатов
ключ - наименование, значение - truе (проходил через список)
Код:
public class CheckVoter {
    private static Map<String, Boolean> voted = new HashMap<>();

    private static void checkVoter(String name) {
        if (voted.containsKey(name)) {
            System.out.println("kick them out!");
        } else {
            voted.put(name, true);
            System.out.println("let them vote!");
        }
    }

    public static void main(String[] args) {
        checkVoter("tom"); // let them vote!
        checkVoter("mike"); // let them vote!
        checkVoter("mike"); // kick them out!
    }
}

Применение в качестве кэша
Код:
public class CashChecker {
    private static Map<String, Data> cash = new HashMap<>();

    private static Data getPage(String url, ) {
        if (cash.containsKey(url)) {
        // возвращаются кэшированные данные
            return cash.get(url);
        } else {
            Data data = getDataFromServer(url);
            cash.put(url, data);
            return data;
        }
    }
}

* HashMap 
-ключи и значения могут быть любых типов, в том числе и null
-разрешение коллизий осуществляется с помощью метода цепочек.

-----------------------------------------------------------------------------------------------

ПОИСК В ШИРИНУ
-алгоритм поиска кратчайшего пути в невзвешанном графе

Граф
-используются для моделирования связей между объектами
-состоят из узлов(ноды) и ребер
-ноды напрямую соединенные друг с другом называются соседями
-представляется в виде х

Поиск в ширину
-относится к алгоритмам поиска
-работает только с графами
-определяет (1) существует ли путь от узла А к узлу В, если существует, то (2) как выглядит кратчайший
-проходя по всем связям всех уровней друг за другом, можно рано или поздно найти путь
-для соблючения очередности проверки уровней связей существует СД ОЧЕРЕДЬ(принцип FIFO)
-проверенный элемент должен удаляться из очереди, иначе может возникнуть бесконечный цикл
-время выполнения О(кол-во нодов + количество ребер)

Направленный граф - отношения действуют только в одну сторону
Ненаправленный граф - отношения для соседних узлов действуют в обе стороны

Дерево - разновидность графа, в котором нет ребер, указывающих в обратном направлении

Код:

private static Map<String, List<String>> graph = new HashMap<>();

private static boolean search(String name) {

    Queue<String> searchQueue = new ArrayDeque<>(graph.get(name));
    
    // This list is how you keep track of which people you've searched before.
    List<String> searched = new ArrayList<>();

    while (!searchQueue.isEmpty()) {
        String person = searchQueue.poll();
        // Only search this person if you haven't already searched them
        if (!searched.contains(person)) {
            if (personIsSeller(person)) {
                System.out.println(person + " is a mango seller!");
                return true;
            } else {
                searchQueue.addAll(graph.get(person));
                // Marks this person as searched
                searched.add(person);
            }
        }
    }
    return false;
}

private static boolean personIsSeller(String name) {
    return name.endsWith("m");
}

public static void main(String[] args) {

    graph.put("you", Arrays.asList("alice", "bob", "claire"));
    graph.put("bob", Arrays.asList("anuj", "peggy"));
    graph.put("alice", Arrays.asList("peggy"));
    graph.put("claire", Arrays.asList("thom", "jonny"));
    graph.put("anuj", Collections.emptyList());
    graph.put("peggy", Collections.emptyList());
    graph.put("thom", Collections.emptyList());
    graph.put("jonny", Collections.emptyList());

    search("you");
}
------------------------------------------------------------------------------------------------

АЛГОРИТМ ДЕЙКСТРЫ
-алгоритм поиска кратчайшего пути (с наименьшей стоимостью) во взвешанном графе
-работае только с НАПРАВЛЕННЫМИ АЦИКЛИЧЕСКИМИ ГРАФАМИ (DAG)

состоит из 4х шагов:
1. Найти узел с наименьшей стоимостью (то есть узел до которого можно добраться за минимальное время)
2. Обновить стоимости соседей узла 
3. Повторять пока это не будет сделано для всех узлов графа
4. Вычислить итоговый путь

В алгоритме Дейкстры каждому сегменту присваивается число (вес)
Алгоритм находит путь с наименьшим суммарным весом

Взвешанные графы
-графы с весами
-графы без весов называютмся невзвешанными

Циклы во взвешанных графах
-увеличивают суммарный вес пути
!В ненаправленных графах каждое ребро добавляет цикл, поэтому алгоритм Дейксты с ними не работает!

*Алгоритм Беллмана-Форда - находит кратчайший путь в графе, содержащем ребра с отрицательным весом


Код:
// Для реализации алгоритма Декстры понадобятся 3 хэш-таблицы: граф, стоимости, родители

public class DijkstrasAlgorithm {
    // the graph
    private static Map<String, Map<String, Double>> graph = new HashMap<>();
    private static List<String> processed = new ArrayList<>();

    private static String findLowestCostNode(Map<String, Double> costs) {
        Double lowestCost = Double.POSITIVE_INFINITY;
        String lowestCostNode = null;

        // Go through each node
        for (Map.Entry<String, Double> node : costs.entrySet()) {
            Double cost = node.getValue();
            // If it's the lowest cost so far and hasn't been processed yet...
            if (cost < lowestCost && !processed.contains(node.getKey())) {
                // ... set it as the new lowest-cost node.
                lowestCost = cost;
                lowestCostNode = node.getKey();
            }
        }

        return lowestCostNode;
    }

    public static void main(String[] args) {
        graph.put("start", new HashMap<>());
        graph.get("start").put("a", 6.0);
        graph.get("start").put("b", 2.0);

        graph.put("a", new HashMap<>());
        graph.get("a").put("fin", 1.0);

        graph.put("b", new HashMap<>());
        graph.get("b").put("a", 3.0);
        graph.get("b").put("fin", 5.0);

        graph.put("fin", new HashMap<>());

        // The costs table
        Map<String, Double> costs = new HashMap<>();
        costs.put("a", 6.0);
        costs.put("b", 2.0);
        costs.put("fin", Double.POSITIVE_INFINITY);

        // the parents table
        Map<String, String> parents = new HashMap<>();
        parents.put("a", "start");
        parents.put("b", "start");
        parents.put("fin", null);

        String node = findLowestCostNode(costs);
        while (node != null) {
            Double cost = costs.get(node);
            // Go through all the neighbors of this node

            Map<String, Double> neighbors = graph.get(node);

            for (String n : neighbors.keySet()) {
                double newCost = cost + neighbors.get(n);
                // If it's cheaper to get to this neighbor by going through this node
                if (costs.get(n) > newCost) {
                    // ... update the cost for this node
                    costs.put(n, newCost);
                    // This node becomes the new parent for this neighbor.
                    parents.put(n, node);
                }
            }
            // Mark the node as processed
            processed.add(node);

            // Find the next node to process, and loop
            node = findLowestCostNode(costs);
        }

        System.out.println("Cost from the start to each node:");
        System.out.println(costs); // { a: 5, b: 2, fin: 6 }
    }
}
-------------------------------------------------------------------------------------------------

ЖАДНЫЕ АЛГОРИТМЫ
-на каждом шаге выбирает оптимальный вариант

Код:
// цель: найти минимальный набор станций который покрывал бы все штаты
public class SetCovering {
    public static void main(String... args) {
        var statesNeeded = new HashSet<>(Arrays.asList("mt", "wa", "or", "id", "nv", "ut", "ca", "az"));
        var stations = new LinkedHashMap<String, Set<String>>();

        stations.put("kone", new HashSet<>(Arrays.asList("id", "nv", "ut")));
        stations.put("ktwo", new HashSet<>(Arrays.asList("wa", "id", "mt")));
        stations.put("kthree", new HashSet<>(Arrays.asList("or", "nv", "ca")));
        stations.put("kfour", new HashSet<>(Arrays.asList("nv", "ut")));
        stations.put("kfive", new HashSet<>(Arrays.asList("ca", "az")));

        var finalStations = new HashSet<String>();
        while (!statesNeeded.isEmpty()) {
            String bestStation = null;
            var statesCovered = new HashSet<String>();

            for (var station : stations.entrySet()) {
                var covered = new HashSet<>(statesNeeded);
                covered.retainAll(station.getValue());

                if (covered.size() > statesCovered.size()) {
                    bestStation = station.getKey();
                    statesCovered = covered;
                }
            }
            statesNeeded.removeIf(statesCovered::contains);

            if (bestStation != null) {
                finalStations.add(bestStation);
            }
        }
        System.out.println(finalStations); // [ktwo, kone, kthree, kfive]
    }
}

NP-полые задачи - задачи с вычислением каждого возможного решения и выбором минимального (кратчайшего)
Например в задаче о коммивояжере при выборе следующего города следует выбирать ближайший из тех, что он не посещал, начать можно с произвольного города.

Признаки NP-полых задач:
*алгоритм быстро работает при малом количестве элементов, но сильно замедляется при увеличении их колличества
*формулировка "все комбинации Х"
*задачу невозможно разбить на подзадачи, приходится вычислять все варианты Х
*в задаче встречается некоторое множество и она не имеет простого решения
-------------------------------------------------------------------------------------------------
ДИНАМИЧЕСКОЕ ПРОГРАММИРОВАНИЕ
