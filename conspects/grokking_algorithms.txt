СОДЕРЖАНИЕ ПО СТРОКАМ
Бинарный поиск              -26
Big O                       -60
Сортировка выбором          -70
Пузырьковая сортировка      -95
Рекурсия                    -120
Разделяй и властвуй         -155
Быстрая сортировка          -186
Хэш-таблицы                 -240
Поиск в ширину              -320















БИНАРНЫЙ ПОИСК 
алгоритм поиска в отсортированном списке элементов

- при каждой итерации исключается половина элементов
- для списка из n элементов бинарный поиск выполняется за log2n шагов

Код:
// цель: найти индекс item в списке list

int search(List<Integer> list, int item) {
// определяем границы поиска
  int low = 0;
  int high = list.size() - 1;
  
  int mid;
  int guess;
  
  // пока эта часть не сократится до одного элемента
  while (low <= high) {
    mid = (low + high) / 2;
    guess = list.get(mid);
    if (guess == item) {
      return mid ; 
    } else if (guess > item) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return -1;
}
-------------------------------------------------------------------------------

BIG O
сравнивает количество операций, а не скорость в секундах

0(1) - константное время. Пример: обращение к элементу массива по индексу
O(log n) - логарифмическое время. Пример: бинарный поиск
O(n) - линейное время. Пример: простой поиск методом перебора
O(n * log n) - Пример: эффективные алгоритмы сортировки
O(n^2) - Пример: вложеные циклы
O(n!) - факториальное время. Пример: очень медленные алгоритмы
-------------------------------------------------------------------------------

CОРТИРОВКА ВЫБОРОМ
- выполняется за O(n^2) путем перебора массива и перекладывания элементов в новый массив

Код:
// цель:выполнить сортировку массива по возрастванию
// шаг 1 - пишем простой метод для перемены мест чисел в массиве
void swap(int[] array, int ind1, int ind2) {
    int tmp = array[ind1];
    array[ind1] = array[ind2];
    array[ind2] = tmp;
}
// шаг 2 - пишем метод сортировки
int[] selectionSort(int[] array) {
    for (int left = 0; left < array.length; left++) {
        int minInd = left;
        for (int i = left; i < array.length; i++) {
            if (array[i] < array[minInd]) {
                minInd = i;
            }
        }
        swap(array, left, minInd);
    }
    return array;
}
------------------------------------------------------------------------------------

ПУЗЫРЬКОВАЯ СОРТИРОВКА (глупая сортировка)
- выполняется за O(n^2) путем перебора массива и сменой мест с соседним элементом

Код:
// цель:выполнить сортировку массива по возрастванию
// шаг 1 - метод swap (выше)
// шаг 2 - метод сортировки
int[] bubbleSort(int[] array) {
  boolean needIteration = true;
  while (needIteration) {
    needIteration = false;
    for (int i = 1; i < array.length; i++) {
      if (array[i] < array[i - 1]) {
        swap(array, i, i-1);
        needIteration = true;
      }
    }
  }
  return array;
}

Массивы - отлично подходят для чтения элементов в произвольных позициях
Связанные списки - идеально подходят для добавления и удаления, но поддерживают только 
последовательный доступ
---------------------------------------------------------------------------------------

РЕКУРСИЯ
Базовый случай - момент в который необходимо прервать рекурсию
Рекурсивный случай - момент а который необходимо продолжить рекурсию

Код:
// цель: обратный отсчет от i до 1
void countdown(int i) {
  System.out.println(i);
  // базовый случай
  if (i <= 1) {
    return;
  // рекурсивный случай
  } else {
    countdown(i - 1);
  }
}

Стек вызовов
Когда функция(2) вызывается из другой функции(1), вызывающая функция(1) приостанавливается в частично завершенном состоянии. А когда функция 2 будет выполнена, мы вернемся к функции 1, ее выполнение продожится там, где прервалось.

Код:
// нахождение факториала числа x
int fact(int x) {
  if (x == 1) {
    return 1;
  } else {
    return x * fact(x - 1);
  }
}

Минусы:
- сохранение всей промежуточной информации может привести к значительным потерям памяти
-------------------------------------------------------------------------------------------------

РАЗДЕЛЯЙ И ВЛАСТВУЙ
- целый подход к решению задач

шаг 1 - определяем простейший случай как базовый
шаг 2 - придумываем как свести задачу к базовому случаю

Код:
// цель: просуммировать числа в массиве
// способ 1 (без рекурсии)
int findSum(int[] arr) {
  int total = 0;
  for (int num : arr) {
    total += num;
  }
  return total;
}

// способ 2 (с рекурсией)
за базовый случай берем пустой массив либо список и вытаскиваем оттуда по одному элементу пока не наступит базовый случай
// размер массива передаем в параметры
static int findSum(int[] arr, int length) {
  if (length <= 0)
    return 0;
  return (arr[length - 1] + findSum(arr, length - 1));
}

Функциональное программирование
- не предусматривает применение циклов, поэтому все типовые задачи решаются через рекурсию
-------------------------------------------------------------------------------------------------

БЫСТРАЯ СОРТИРОВКА
- работает немного быстрее сортировки выбором

Базовый случай: arr.length == 0 || == 1
-такие массивы просто возвращаются в исходном виде
-массив должен разделяться пока мы не придем к базовому случаю

1-находим ОПОРНЫЙ ЭЛЕМЕНТ
2-делаем разделение - находим элементы больше опорного и меньше 
3-эти элементы образуют 2 подмассива

Код:
// шаг 1 - метод swap

// шаг 2 - разделение
int partition(int arr[], int first, int last)
{
    // Choosing the pivot
    int pivot = arr[last];

    // Setting the wall
    int wall = (first - 1);

    for (int current = first; current < last; current++) {

        // If current element is smaller than the pivot
        if (arr[current] < pivot) {

            // Increment index of wall and do a swap
            wall++;
            swap(arr, wall, current);
        }
    }
    
    swap(arr, wall + 1, last);
    return (wall + 1);
}

// шаг 3 - сортировка
void quickSort(int arr[], int first, int last)
{
    if (first < last) {

        // doing partition
        int pivot = partition(arr, first, last);

        // Separately sort elements before partition and after partition
        quickSort(arr, first, pivot - 1);
        quickSort(arr, pivot + 1, last);
    }
}

--------------------------------------------------------------------------------------------

ХЕШ-ТАБЛИЦЫ

Хеш-функция представляет собой функцию, которая получает строку и возвращает индекс ячейки (бакет) динамически расширяемого массива, иными словами она отображает строки на числа.
Принципы работы:
-при передаче в хеш-функцию одного и того же слова будет возвращен один и тот же индекс
-разным словам соответствуют разные индексы
-хеш-функция неизменно связывает название с одним индексом

хеш-функция + массив = хеш-таблица
!!!Хеш-функция определяет место хранения элемента в массиве и делает это за константное время О(1) в лучшем и среднем случаях и за линейное О(n) в худшем случае

ключ хеш-таблицы - индекс элемента массива
значение хеш-таблицы - сам элемент

КОЛЛИЗИИ

-ситуация при которой двум ключам назначается один элемент массива
Решения коллизий:
-если несколько ключей отображаются на один элемент, тогда в элементе создается связанный список

Таким образом хеш-функция должна распределять ключи равномерно по всему хешу, тк если связанные списки становятся слишком длинными, работа с таблицей сильно замедлится.

КОЭФФИЦИЕНТ ЗАПОЛНЕНИЯ

КЗ = Q элементов в хэш-таблице(занятых ячеек) / общее Q элементов(занятых + пустых ячеек)
-по КЗ можно оценить количество пустых ячеек в хэш-таблице
-чем меньше КЗ - тем лучше
-при КЗ > 0.7 пора изменять размер таблицы

ПРИМЕНЕНИЕ ХЕШ-ТАБЛИЦ:

Преобразование DNS
-это преобразование названия веб-сайта в IP-адрес (например google.com -> 74.125.239.133) 
-работает по принципу хеш-таблицы (название сайта - ключ, IP - значение)

Исключение дубликатов
ключ - наименование, значение - truе (проходил через список)
Код:
public class CheckVoter {
    private static Map<String, Boolean> voted = new HashMap<>();

    private static void checkVoter(String name) {
        if (voted.containsKey(name)) {
            System.out.println("kick them out!");
        } else {
            voted.put(name, true);
            System.out.println("let them vote!");
        }
    }

    public static void main(String[] args) {
        checkVoter("tom"); // let them vote!
        checkVoter("mike"); // let them vote!
        checkVoter("mike"); // kick them out!
    }
}

Применение в качестве кэша
Код:
public class CashChecker {
    private static Map<String, Data> cash = new HashMap<>();

    private static Data getPage(String url, ) {
        if (cash.containsKey(url)) {
        // возвращаются кэшированные данные
            return cash.get(url);
        } else {
            Data data = getDataFromServer(url);
            cash.put(url, data);
            return data;
        }
    }
}

* HashMap 
-ключи и значения могут быть любых типов, в том числе и null
-разрешение коллизий осуществляется с помощью метода цепочек.
-----------------------------------------------------------------------------------------------

ПОИСК В ШИРИНУ

