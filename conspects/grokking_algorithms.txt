СОДЕРЖАНИЕ ПО СТРОКАМ
Бинарный поиск              -27
Big O                       -60
Сортировка выбором          -70
Пузырьковая сортировка      -95
Рекурсия                    -120
Разделяй и властвуй         -155
Быстрая сортировка          -186
Хэш-таблицы                 -245

















БИНАРНЫЙ ПОИСК 
алгоритм поиска в отсортированном списке элементов

- при каждой итерации исключается половина элементов
- для списка из n элементов бинарный поиск выполняется за log2n шагов

Код:
// цель: найти индекс item в списке list

int search(List<Integer> list, int item) {
// определяем границы поиска
  int low = 0;
  int high = list.size() - 1;
  
  int mid;
  int guess;
  
  // пока эта часть не сократится до одного элемента
  while (low <= high) {
    mid = (low + high) / 2;
    guess = list.get(mid);
    if (guess == item) {
      return mid ; 
    } else if (guess > item) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return -1;
}
-------------------------------------------------------------------------------

BIG O
сравнивает количество операций, а не скорость в секундах

O(log n) - логарифмическое время. Пример: бинарный поиск
O(n) - линейное время. Пример: простой поиск методом перебора
O(n * log n) - Пример: эффективные алгоритмы сортировки
O(n^2) - Пример: вложеные циклы
O(n!) - Пример: очень медленные алгоритмы
-------------------------------------------------------------------------------

CОРТИРОВКА ВЫБОРОМ
- выполняется за O(n^2) путем перебора массива и перекладывания элементов в новый массив

Код:
// цель:выполнить сортировку массива по возрастванию
// шаг 1 - пишем простой метод для перемены мест чисел в массиве
void swap(int[] array, int ind1, int ind2) {
    int tmp = array[ind1];
    array[ind1] = array[ind2];
    array[ind2] = tmp;
}
// шаг 2 - пишем метод сортировки
int[] selectionSort(int[] array) {
    for (int left = 0; left < array.length; left++) {
        int minInd = left;
        for (int i = left; i < array.length; i++) {
            if (array[i] < array[minInd]) {
                minInd = i;
            }
        }
        swap(array, left, minInd);
    }
    return array;
}
------------------------------------------------------------------------------------

ПУЗЫРЬКОВАЯ СОРТИРОВКА (глупая сортировка)
- выполняется за O(n^2) путем перебора массива и сменой мест с соседним элементом

Код:
// цель:выполнить сортировку массива по возрастванию
// шаг 1 - метод swap (выше)
// шаг 2 - метод сортировки
int[] bubbleSort(int[] array) {
  boolean needIteration = true;
  while (needIteration) {
    needIteration = false;
    for (int i = 1; i < array.length; i++) {
      if (array[i] < array[i - 1]) {
        swap(array, i, i-1);
        needIteration = true;
      }
    }
  }
  return array;
}

Массивы - отлично подходят для чтения элементов в произвольных позициях
Связанные списки - идеально подходят для добавления и удаления, но поддерживают только 
последовательный доступ
---------------------------------------------------------------------------------------

РЕКУРСИЯ
Базовый случай - момент в который необходимо прервать рекурсию
Рекурсивный случай - момент а который необходимо продолжить рекурсию

Код:
// цель: обратный отсчет от i до 1
void countdown(int i) {
  System.out.println(i);
  // базовый случай
  if (i <= 1) {
    return;
  // рекурсивный случай
  } else {
    countdown(i - 1);
  }
}

Стек вызовов
Когда функция(2) вызывается из другой функции(1), вызывающая функция(1) приостанавливается в частично завершенном состоянии. А когда функция 2 будет выполнена, мы вернемся к функции 1, ее выполнение продожится там, где прервалось.

Код:
// нахождение факториала числа x
int fact(int x) {
  if (x == 1) {
    return 1;
  } else {
    return x * fact(x - 1);
  }
}

Минусы:
- сохранение всей промежуточной информации может привести к значительным потерям памяти
-------------------------------------------------------------------------------------------------

РАЗДЕЛЯЙ И ВЛАСТВУЙ
- целый подход к решению задач

шаг 1 - определяем простейший случай как базовый
шаг 2 - придумываем как свести задачу к базовому случаю

Код:
// цель: просуммировать числа в массиве
// способ 1 (без рекурсии)
int findSum(int[] arr) {
  int total = 0;
  for (int num : arr) {
    total += num;
  }
  return total;
}

// способ 2 (с рекурсией)
за базовый случай берем пустой массив либо список и вытаскиваем оттуда по одному элементу пока не наступит базовый случай
// размер массива передаем в параметры
static int findSum(int[] arr, int length) {
  if (length <= 0)
    return 0;
  return (arr[length - 1] + findSum(arr, length - 1));
}

Функциональное программирование
- не предусматривает применение циклов, поэтому все типовые задачи решаются через рекурсию
-------------------------------------------------------------------------------------------------

БЫСТРАЯ СОРТИРОВКА
- работает немного быстрее сортировки выбором

Базовый случай: arr.length == 0 || == 1
-такие массивы просто возвращаются в исходном виде
-массив должен разделяться пока мы не придем к базовому случаю

1-находим ОПОРНЫЙ ЭЛЕМЕНТ
2-делаем разделение - находим элементы больше опорного и меньше 
3-эти элементы образуют 2 подмассива

Код:
// шаг 1 - метод swap

// шаг 2 - разделение
int partition(int arr[], int low, int high)
{
    // Choosing the pivot
    int pivot = arr[high];

    // Index of smaller element and indicates
    // the right position of pivot found so far
    int i = (low - 1);

    for (int j = low; j <= high - 1; j++) {

        // If current element is smaller than the pivot
        if (arr[j] < pivot) {

            // Increment index of smaller element
            i++;
            swap(arr, i, j);
        }
    }
    swap(arr, i+1, high);
    return (i + 1);
}

// шаг 3 - сортировка
// arr[] --> Array to be sorted,
// low --> Starting index,
// high --> Ending index
void quickSort(int arr[], int low, int high)
{
    if (low < high) {

        // pivot is partitioning index, arr[p]
        // is now at right place
        int pivot = partition(arr, low, high);

        // Separately sort elements before
        // partition and after partition
        quickSort(arr, low, pivot - 1);
        quickSort(arr, pivot + 1, high);
    }
}

--------------------------------------------------------------------------------------------

ХЕШ-ТАБЛИЦЫ
