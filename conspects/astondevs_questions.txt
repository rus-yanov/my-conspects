BLOCK #1

1. В каком случае время выполнения операции с HashMap будет равно O(n)?
- при чтении из-за LinkedList, или при добавлении из-за массива
- во всех остальных случаях O(1)

2. Зачем использовать Comparator с методом compare(), если уже есть Comparable с методом compareTo()?
-Иногда мы не можем изменить исходный код класса, объекты которого мы хотим отсортировать, что делает использование Comparable невозможным.
-Использование Comparators позволяет нам избежать добавления дополнительного кода в наши доменные классы
-Мы можем определить несколько различных стратегий сравнения, что невозможно при использовании Comparable

3. Что произойдет если добавить дубликат в Set?
-ничего, метод add() вернет false

4. Как можно реализовать граф (невзвеш/взвеш) в Java?
-невзвешанный - HashMap<String, List<String>>
-взвешанный - через отдельный класс вес указываем в конструкторе

5. Зачем добавили ArrayList если уже был Vector?
-методы в ArrayList не являются синхронизированными(потокобезопасными), что делает его быстрее

6. Ковариантность. Что будет если попытаться получить потомок Type из List<? extends Type>?
-код не скомпилируется
-Во время компиляции кода неизвестно, объекты какого именно класса будут содержаться в листе. Допустим, это будут объекты Class3. Тогда в этой строке
Class4 class4 = list.get(0);
мы получим объект класса-предка и попытаемся положить его в переменную, имеющую тип класса-потомка, чего Java конечно же сделать неявно не позволит. 
Впрочем, если мы гарантируем компилятору, что точно знаем, объекты какого класса будут лежать в данном листе, то легко сможем с ним договориться.
Class4 class4 = (Class4) list.get(0);

7. Как можно отменить коммит в Git, если он уже был опубликован ?
-делав обратный коммит с помощью команды git revert [commit SHA]. Это создаст коммит отменяющий изменения указанного коммита. 
После необходимо отправить изменения в удаленный репозиторий с помощью команды git push [repository]/branch-name. Если коммит сделан на личной ветке, не используемой никем кроме автора, ошибочный коммит можно отметить флагом drop в интерактивном режиме ребейза (git rebase -i), 
что полностью удалит указанный коммит из истории. После необходимо отправить изменения в удаленный репозиторий с помощью команды git push [repository]/branch-name с флагом force.

8. За что отвечает команда Git stash?
-команда сохраняющая измененное состояние рабочей директории или отдельного файла в хранилище незавершенных изменений. Это дает возможность в любой момент применить их обратно. Например, если нужно переключиться между ветками без фиксации изменений, можно применить команду git stash, рабочая директория останется без изменений, данные будут сохранены в специальном хранилище. 
Для просмотра спрятанных изменений нужно вызвать команду git stash list, а для применения — git stash apply.

9. Перечислить методы Iterator
-default void forEachRemaining(Consumer<? super E> action) Performs the given action for each remaining element until all elements have been processed or the action throws an exception.
-boolean	hasNext() Returns true if the iteration has more elements.
-E	next() Returns the next element in the iteration.
-default void	remove() Removes from the underlying collection the last element returned by this iterator (optional operation).

10. Что такое инвариантность?
-Инвариантность List<Type> — ситуация, когда наследование исходных типов не переносится на производные. Например при попытке вставить в спискок с объектами класса А список с объектами класса В, объекты кот- орого наследуются от объектов класса А.
Присваивание (=): только List<Type>
get(): Type и предки
add(): Type и наследники


BLOCK #2

1. JRE/JDK. Что такое? Какие компоненты включают?
- Java Runtime Enviroment - среда исполнения программы на java. Включает в себя JVM и базовые библиотеки.
- Java Development Kit - Набор для разработки на java. Включает в себя JRE и javac

2. Стек и куча в java. В чем разница?
- и стек и куча хранят данные программы
- стековая память отвечает за хранение ссылок на объекты кучи и за хранение локальных переменных
- в стеке используются только объекты из активной области
- стековая память в Java выделяется для каждого потока
- размер стека ограничен оп
- куча хранит в памяти фактические объекты, на которые ссылаются переменные из стека
- new - выделяет место в куче
- доступ к куче медленнее чем к стеку
- нет потокобезопасности

3. Что такое индекс в бд? Зачем он нужен?
- это структура данных, которая повышает скорость операций поиска данных в таблице БД за счет дополнительных операций записи и хранения для поддержания структуры данных индекса (как закладка в книге).
-  если не использовать индекс, то для поиска информации будет произведено сканирование каждой строки таблицы. Это значительно понизит производительность и увеличит время поиска.
- отдельная таблица, занимает доп память

5. 5 основных требований к переопределению equals()
-рефлексивность, симметричность, тразитивность, постоянство, not null

6. Что такое JDBC? Что у него под капотом?
- промышленный стандарт взаимодействия Java-приложений с различными СУБД. Реализован в виде пакета java.sql, входящего в состав Java SE.
- основан на концепции драйверов, которые позволяют получать соединение с базой данных по специально описанному URL. При загрузке драйвер регистрирует себя в системе и в дальнейшем автоматически вызывается, когда программа требует URL, содержащий протокол, за который этот драйвер отвечает.

7. Dependency inversion principle 
- программа делится на слои (модули)
- модули верхнего уровня не зависят от модулей нижнего уровня. 
- сделать можно через интерфейс, который будет прослойкой между интерфейсом верхнего и нижнего уровня
- программное обеспечение написано таким образом, что различные модули автономны и соединяются друг с другом с помощью абстракции.

8. Что будет если реализовать два интерфейса с одинаковыми методами?
- если метод дефолтный в обоих интерфейсах, то есть снабжен реализацией. Компилятору изначально понятно, что невозможно будет на момент вызова определить, какой метод реально подразумевался. Так что еще на объявлении класса-реализации компилятор выдаст ошибку «inherits unrelated defaults». В таком случае в классе необходимо переопределить этот общий метод, и явно перенаправить вызов в нужную родительскую реализацию. 
- Если два метода имеют конфликтующие типы возврата, то это будет ошибка компиляции "types are incompatible"
- Если тип реализует два интерфейса, и каждый из них interface определяет метод с одинаковой сигнатурой, то в действительности существует только один метод, и они не различимы. 

9. Транзакции и требования к ним
- транзакции в Java, как и в общем случае, относятся к серии действий, которые все должны завершиться успешно.
- Атомарность (atomicity) гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной.
- Согласованность (consistency) требование, подразумевающее, что в результате работы транзакции данные будут допустимыми. Это вопрос не технологии, а бизнес-логики: например, если количество денег на счете не может быть отрицательным, логика транзакции должна проверять, не выйдет ли в результате отрицательных значений.
- Изолированность (isolation). Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат.
 -Долговечность (durability). Независимо от проблем на нижних уровнях изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу. Другими словами, если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.
 
 10. В чем разница между процессом и потоком?
Поцесс — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое.

Для каждого процесса ОС создает так называемое «виртуальное адресное пространство», к которому процесс имеет прямой доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память.

Поток(thread) — определенный способ выполнения процесса, определяющий последовательность исполнения кода в процессе. Потоки всегда создаются в контексте какого-либо процесса, и вся их жизнь проходит только в его границах. Потоки могут исполнять один и тот же код и манипулировать одними и теми же данными, а также совместно использовать описатели объектов ядра, поскольку таблица описателей создается не в отдельных потоках, а в процессах. Так как потоки расходуют существенно меньше ресурсов, чем процессы, в процессе выполнения работы выгоднее создавать дополнительные потоки и избегать создания новых процессов.
 
BLOCK #3

1.. Стек и куча в java. В чем разница?
- и стек и куча хранят данные программы
- стековая память отвечает за хранение ссылок на объекты кучи и за хранение локальных переменных
- в стеке используются только объекты из активной области
- стековая память в Java выделяется для каждого потока
- размер стека ограничен оп
- куча хранит в памяти фактические объекты, на которые ссылаются переменные из стека
- new - выделяет место в куче
- доступ к куче медленнее чем к стеку
- нет потокобезопасности

2!. Когда HashMap перерождается из связанного списка в массиве в красно-черное дерево?
- когда в одном бакете не менее 8 записей и общее число бакетов больше 64, то этот единственный бакет будет преобразован в идеально сбалансированный узел красно-черного дерева.

3.. 5 основных требований к переопределению equals()
-рефлексивность x.equals(x) == true
-симметричность x.equals(y) == y.equals(x)
-тразитивность x.equals(y) && x.equals(z), то y.equals(z)
-постоянство повторынй вызов будет возвращать значение предыдущего вызова
-not null

4!. Stop-the-world
Для сборки мусора используется алгоритм пометок (Mark & Sweep). Этот алгоритм состоит из трех этапов:
Mark (маркировка). На первом этапе GC сканирует все объекты и помечает живые (объекты, которые все еще используются). На этом шаге выполнение программы приостанавливается. Поэтому этот шаг также называется "Stop the World".
Sweep (очистка). На этом шаге освобождается память, занятая объектами, не отмеченными на предыдущем шаге.
Compact (уплотнение). Объекты, пережившие очистку, перемещаются в единый  непрерывный блок памяти. Это уменьшает фрагментацию кучи и позволяет проще и быстрее размещать новые объекты.

5. Что такое индекс в бд? кластеризованный/некластеризованные?
- это структура данных, которая повышает скорость операций поиска данных в таблице БД за счет дополнительных операций записи и хранения для поддержания структуры данных индекса (как закладка в книге).
- имеет структуру сбалансированного дерева
- если не использовать индекс, то для поиска информации будет произведено сканирование каждой строки таблицы. Это значительно понизит производительность и увеличит время поиска.
- кластеризованный - отдельная таблица, в которой храняться все значения (в листьях дерева), все значения отсортированы в определенном порядке либо возрастания, либо убывания. У таблицы может быть только один кластеризованный индекс.
- листья некластеризованного индекса содержат только те столбцы (ключевые), по которым определен данный индекс, а также содержит указатель на строки с реальными данными в таблице, не могут быть отсортированы в отличие от кластеризованных, однако вы можете создать более одного некластеризованного индекса на таблице или представлении, вплоть до 999

6.. Что такое JDBC? Что у него под капотом?
- промышленный стандарт взаимодействия Java-приложений с различными СУБД. Реализован в виде пакета java.sql, входящего в состав Java SE.
- основан на концепции драйверов, которые позволяют получать соединение с базой данных по специально описанному URL. При загрузке драйвер регистрирует себя в системе и в дальнейшем автоматически вызывается, когда программа требует URL, содержащий протокол, за который этот драйвер отвечает.

7!. Что будет если реализовать два интерфейса с одинаковыми методами?
- если метод дефолтный в обоих интерфейсах, то есть снабжен реализацией. Компилятору изначально понятно, что невозможно будет на момент вызова определить, какой метод реально подразумевался. Так что еще на объявлении класса-реализации компилятор выдаст ошибку «inherits unrelated defaults». В таком случае в классе необходимо переопределить этот общий метод, и явно перенаправить вызов в нужную родительскую реализацию. 
- Если два метода имеют конфликтующие типы возврата, то это будет ошибка компиляции "types are incompatible"
- Если тип реализует два интерфейса, и каждый из них interface определяет метод с одинаковой сигнатурой, то в действительности существует только один метод, и они не различимы. 

8. Atomics
- набор классов для атомарной работы с примитивными типами. Контракт данных классов гарантирует выполнение операции compare-and-set за «1 единицу процессорного времени». При установке нового значения этой переменной вы также передаете ее старое значение (подход оптимистичной блокировки). Если с момента вызова метода значение переменной отличается от ожидаемого — результатом выполнения будет false.

9. Транзакции и требования к ним
- транзакции в Java, как и в общем случае, относятся к серии действий, которые все должны завершиться успешно.
- Атомарность (atomicity) гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной.
- Согласованность (consistency) требование, подразумевающее, что в результате работы транзакции данные будут допустимыми. Это вопрос не технологии, а бизнес-логики: например, если количество денег на счете не может быть отрицательным, логика транзакции должна проверять, не выйдет ли в результате отрицательных значений.
- Изолированность (isolation). Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат.
 -Долговечность (durability). Независимо от проблем на нижних уровнях изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу. Другими словами, если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.
 
 10. N + 1
-возникает когда одна сущность ссылается на другую
-в такой ситуации получается, что для получения значения зависимой сущности выполняется n избыточных запросов, в то время как достаточно одного
-это негативно сказывается на производительность системы и создает лишнюю нагрузку на БД
-количество запросов увеличивается с ростом N
-Решение - использовать JOIN FETCH и jpql на выборку сущности. Данное решение не поддерживает работу с нативными запросами, но работает любым видом OneToMany/ManyToOne связи. Может генерировать дополнительные подзапросы, тогда возможно лучше entityGraph брать, чтобы вместо подзапросов join'ы генерировались

BLOCK #4

1.. Lasy|Eager загрузка
Относится к загрузке дочерних сущностей. Так что первое, что они сделали – это добавили специальный параметр fetch в аннотации @OneToMany, @ManyToMany.
Значения по умолчанию:
-отличаются для различных типов аннотаций. Для аннотаций @OneToOne и @ManyToOne – это EAGER, для аннотаций @OneToMany и @ManyToMany – это LAZY. Запомнить просто – если мы ссылаемся на один объект, то он будет загружен полностью. Если ссылаемся на коллекцию, то она будет загружена при первом обращении к ней.

2!. 

3.. 5 основных требований к переопределению equals()
-рефлексивность x.equals(x) == true
-симметричность x.equals(y) == y.equals(x)
-тразитивность x.equals(y) && x.equals(z), то y.equals(z)
-постоянство повторынй вызов будет возвращать значение предыдущего вызова
-not null

4!. 

5. 

6.. Что такое JDBC? Что у него под капотом?
- промышленный стандарт взаимодействия Java-приложений с различными СУБД. Реализован в виде пакета java.sql, входящего в состав Java SE.
- основан на концепции драйверов, которые позволяют получать соединение с базой данных по специально описанному URL. При загрузке драйвер регистрирует себя в системе и в дальнейшем автоматически вызывается, когда программа требует URL, содержащий протокол, за который этот драйвер отвечает.

7!. Что будет если реализовать два интерфейса с одинаковыми методами?
- если метод дефолтный в обоих интерфейсах, то есть снабжен реализацией. Компилятору изначально понятно, что невозможно будет на момент вызова определить, какой метод реально подразумевался. Так что еще на объявлении класса-реализации компилятор выдаст ошибку «inherits unrelated defaults». В таком случае в классе необходимо переопределить этот общий метод, и явно перенаправить вызов в нужную родительскую реализацию. 
- Если два метода имеют конфликтующие типы возврата, то это будет ошибка компиляции "types are incompatible"
- Если тип реализует два интерфейса, и каждый из них interface определяет метод с одинаковой сигнатурой, то в действительности существует только один метод, и они не различимы. 

8. Atomics
- набор классов для атомарной работы с примитивными типами. Контракт данных классов гарантирует выполнение операции compare-and-set за «1 единицу процессорного времени». При установке нового значения этой переменной вы также передаете ее старое значение (подход оптимистичной блокировки). Если с момента вызова метода значение переменной отличается от ожидаемого — результатом выполнения будет false.

9. Транзакции и требования к ним
- транзакции в Java, как и в общем случае, относятся к серии действий, которые все должны завершиться успешно.
- Атомарность (atomicity) гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной.
- Согласованность (consistency) требование, подразумевающее, что в результате работы транзакции данные будут допустимыми. Это вопрос не технологии, а бизнес-логики: например, если количество денег на счете не может быть отрицательным, логика транзакции должна проверять, не выйдет ли в результате отрицательных значений.
- Изолированность (isolation). Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат.
 -Долговечность (durability). Независимо от проблем на нижних уровнях изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу. Другими словами, если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.
 
 10. N + 1
-возникает когда одна сущность ссылается на другую
-в такой ситуации получается, что для получения значения зависимой сущности выполняется n избыточных запросов, в то время как достаточно одного
-это негативно сказывается на производительность системы и создает лишнюю нагрузку на БД
-количество запросов увеличивается с ростом N
-Решение - использовать JOIN FETCH и jpql на выборку сущности. Данное решение не поддерживает работу с нативными запросами, но работает любым видом OneToMany/ManyToOne связи. Может генерировать дополнительные подзапросы, тогда возможно лучше entityGraph брать, чтобы вместо подзапросов join'ы генерировались
