БЛОК 1

АЛГОРИТМЫ И СТРУКТУРЫ ДАННЫХ
см грокаем алгоритмы
вопросы-ответы по JCF


ШАБЛОНЫ ПРОЕКТИРОВАНИЯ(паттерн)
-это эффективные способы решения характерных задач проектирования. Паттерн не является законченным образцом проекта, который может быть прямо преобразован в код, скорее это описание или образец того как решить задачу таким образом чтоб это можно было использовать в различных ситуациях

ООП --> Три принципа ООП --> Шаблоны GRASP --> Шаблоны GoF

ООП - парадигма программирования основанное на объектах, их отождествлении с объектами предметной области
Состояние объекта - значения полей
Поведение объекта - методы

Принципы ООП:
Инкапсуляция - это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя, открыв только то, что необходимо при последующем использовании
Наследование - это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.
Полиморфизм - это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
 
Шаблоны GRASP (принципы)
general responsibility assignment software patterns
-  a set of "nine fundamental principles in object design and responsibility assignment" first published by Craig Larman in his 1997 book Applying UML and Patterns.
 
1. Information expert - информацию должен обрабатывать тот, у кого она есть (слабая связанность)
2. Creator - новый экземпляр класса должен создавать тот класс, который им пользуется (слабая связанность)
3. Controller - обязанности по обработке системных сообщений делегируются специальному классу. 
Контроллер - это объект, который отвечает за обработку системных событий и не относится к интерфейсу пользователя. Контроллер определяет методы для выполнения системных операций
4. Low coupling - низкая связанность - распределить обязанности между объектами так, чтобы степень связанности оставалась низкой, чтоб они не влияли друг на друга там, где не надо
5. High cohesion - высокое зацепление - в одной части системы должны находится однородные данные 
6. Polymorphism - обрабатывать альтернативные варианты поведения на основе типа следует через распределение обязанностей с помощью полиморфных операций для этого класса. Заменить if/switch на полиморфное поведение.
7.Pure fabrication -  присвоить группу обязанносткей классу, который не представляет конкретного понятия из предметной области. Например: фасад в БД
8. Inderection = Dependency injection(SOLID)
9. Protected variations - устойчивый к изменениям - чтоб изменения одних элементов системы не влияло на другие следует идентифицировать точки возможных изменений или неустойчивости и распределить обязанности таким образом, чтобы обеспечить устойчивую работу системы 



SOLID
Пять основных принципов дизайна классов:

Single Responsibility Principle (Принцип единственной ответственности).
Open Closed Principle (Принцип открытости/закрытости).
Liskov’s Substitution Principle (Принцип подстановки Барбары Лисков).
Interface Segregation Principle (Принцип разделения интерфейса).
Dependency Inversion Principle (Принцип инверсии зависимостей).

Принцип единственной ответственности (SRP)
Никогда не должно быть больше одной причины изменить класс.
Класс должен быть ответственен лишь за что-то одно. Если класс отвечает за решение нескольких задач, его подсистемы, реализующие решение этих задач, оказываются связанными друг с другом. Изменения в одной такой подсистеме ведут к изменениям в другой.
Представьте себе модуль, который обрабатывает заказы. Если заказ верно сформирован, он сохраняет его в базу данных и высылает письмо для подтверждения заказа. Принцип единственной обязанности подразумевает, что три аспекта этой проблемы на самом деле — три разные обязанности. А значит, должны находиться в разных классах или модулях. Объединение нескольких сущностей, которые могут меняться в разное время и по разным причинам, считается плохим проектным решением. Гораздо лучше разделить модуль на три отдельных, каждый из которых будет выполнять одну единственную функцию.

Принцип открытости/закрытости (OCP)
Программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.
Это означает, что должна быть возможность изменять внешнее поведение класса, не внося физические изменения в сам класс. Следуя этому принципу, классы разрабатываются так, чтобы для подстройки класса к конкретным условиям применения было достаточно расширить его и переопределить некоторые функции. Поэтому система должна быть гибкой, с возможностью работы в переменных условиях без изменения исходного кода. Используются интерфейсы

Принцип подстановки Барбары Лисков (LSP)
Объекты в программе можно заменить их наследниками без изменения свойств программы.
Это означает, что класс, разработанный путем расширения на основании базового класса, должен переопределять его методы так, чтобы не нарушалась функциональность с точки зрения клиента. То есть, если разработчик расширяет ваш класс и использует его в приложении, он не должен изменять ожидаемое поведение переопределенных методов. Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.

Принцип разделения интерфейса (ISP)
Клиенты не должны быть вынуждены реализовывать методы, которые они не будут использовать.
Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более мелкие и специфические, чтобы клиенты мелких интерфейсов знали только о методах, необходимых в работе.
Рассмотрим пример. Разработчик Алекс создал интерфейс "отчет" и добавил два метода: generateExcel() и generatedPdf(). Теперь клиент А хочет использовать этот интерфейс, но он намерен использовать отчеты только в PDF-формате, а не в Excel. Он должен будет реализовать два метода, один из которых по большому счету не нужен и существует только благодаря Алексу — дизайнеру программного обеспечения. Клиент воспользуется либо другим интерфейсом, либо оставит поле для Excel пустым. Так в чем же решение? Оно состоит в разделении существующего интерфейса на два более мелких. Один — отчет в формате PDF, второй — отчет в формате Excel. Это даст пользователю возможность использовать только необходимый для него функционал.

Принцип инверсии зависимостей (DIP)
Зависимости внутри системы строятся на основе абстракций. Объектом зависимости должна быть абстракция, а не что-то конкретное. Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. Программное обеспечение нужно разрабатывать так, чтобы различные модули были автономными и соединялись друг с другом с помощью абстракции.
Классическое применение этого принципа — Spring framework. В рамках Spring framework все модули выполнены в виде отдельных компонентов, которые могут работать вместе. Они настолько автономны, что могут быть быть с такой же легкостью задействованы в других программных модулях помимо Spring framework. Это достигнуто за счет зависимости закрытых и открытых принципов. Все модули предоставляют доступ только к абстракции, которая может использоваться в другом модуле.

ПРОЧИЕ ПРИНЦИПЫ РАЗРАБОТКИ
YAGNI (you are not gonna need it)
-не заказывали - не делай
-бесплатных функций не бывает
-придется переделывать
 
DRY (don't repeat yourself)
-каждая часть знания должна иметь единственное представление в рамках системы
-избегать дублирования данных
-декомпозировать задачу
-не повторять написанный код в другой задаче
-модульное проектирование (SRP)

KISS (keep it simple, stupid)
-делать максимально просто, дубово
-YAGNI - нет лишним функциям
-DRY - декомпозиция на модули
-precistion design is fragile


PECS (producer extends - consumer super) |  Ковариантность и контрвариантность обобщенных классов
- если у нас есть некая коллекция, типизированная wildcard с верхней границей (extends) – то это, «продюсер». Он только «продюсирует», предоставляет элемент из контейнера, а сам ничего не принимает, предназначен только для чтения. Если же у нас коллекция, типизированная wildcard по нижней границе (super) – то это, «потребитель», который «только принимает, а предоставить ничего не может».

Инвариантность List<Type> — ситуация, когда наследование исходных типов не переносится на производные. Например при попытке вставить в спискок с объектами класса А список с объектами класса В, объекты которого наследуются от объектов класса А.
Присваивание (=): только List<Type>
get(): Type и предки
add(): Type и наследники
-----------------------------
Ковариантность List<? extends Type> — перенос наследования исходных типов на производные от них типы в прямом порядке.
Присваивание (=): List<Type> и List<? extends Type>
get(): Type и предки
add(): НИЧЕГО
------------------------------
Контравариантность List<? super Type> — перенос наследования исходных типов на производные от них типы в обратном порядке.
Присваивание (=): List<Type> и List<? super Type>
get(): Object
add(): Type и наследники


GIT
подход Git к хранению данных больше похож на набор снимков миниатюрной файловой системы. Каждый раз, когда вы делаете коммит, то есть сохраняете состояние своего проекта в Git, система запоминает, как выглядит каждый файл в этот момент, и сохраняет ссылку на этот снимок. Для увеличения эффективности, если файлы не были изменены, Git не запоминает эти файлы вновь, а только создаёт ссылку на предыдущую версию идентичного файла, который уже сохранён. Git представляет свои данные как, скажем, поток снимков.

Что умеет гит:
-предоставляет историю разработки
-дает права доступа к коду
-предоставляет контроль версий

Три состояния:
staged - подготовленные файлы — это изменённые файлы, отмеченные для включения в следующий коммит.
modified - к изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы.
commited - зафиксированный значит, что файл уже сохранён в вашей локальной базе.

Основные комманды
git init – создание репозитория
git status – текущее состояние файлов в папке
git add – добавить отслеживания файла 
git push – отправит изменения на репозиторий
git commit – сохранить изменения 
git stash – сохраняет изменения в отдельную папку 
git apply – возвращает изменения из stash

Слияние — обычная практика для разработчиков, использующих системы контроля версий. Независимо от того, созданы ли ветки для тестирования, исправления ошибок или по другим причинам, слияние фиксирует изменения в другом месте. Слияние принимает содержимое ветки источника и объединяет их с целевой веткой. В этом процессе изменяется только целевая ветка. История исходных веток остается неизменной.

Rebase — еще один способ перенести изменения из одной ветки в другую. Rebase сжимает все изменения в один «патч». Затем он интегрирует патч в целевую ветку. В отличие от слияния, перемещение перезаписывает историю, потому что она передает завершенную работу из одной ветки в другую. В процессе устраняется нежелательная история.

git cherry-pick - это команда в системе контроля версий Git, которая позволяет выбирать и применять (переносить) коммиты из одной ветки в другую. Эта команда полезна, когда вы хотите применить только определенные коммиты из одной ветки в другую, а не весь набор изменений. 

РАЗБОР ВОПРОСОВ ИЗ СРЕЗА 20.06.2023

1. Принципы солид, каждый подробно с примерами
2. О большое, временная, пространственная сложность
3. Хеш-мапы, внутреннее устройство
4. Гит, все операции при работе над общим проектом, merge vs rebase
5. Многопоточность, атомики, пакет concurrent и ещё что-то не помню
6. Хибернейт, entity, n+1, lazy initialization
7. Sql: while vs having, подробно по индексам
8. Сборщики проекта. Maven, gradle

1. Liskov substitution principle
Класс наследник должен уметь реализовывать те методы, которые реализовывает его родительский класс, т.о разрешается только добавлять функционал, но не урезать его.

2. Как ведется совместная разработка в гите
-ответвляемся от master ветки в свою ветку
-делаем изменения
-коммитим
-пушим
-кодревьюер проверит изменения в новой ветки, если все ок он смержит их в master

3. Stop the world

4. Перестроение односвязанного списка в бакете в дерево

5. Пакет concurent

6. Lazy init

7. N+1

8. Build Tools: жизненный цикл
